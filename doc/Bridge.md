## Bridge测试文档

### 测试逻辑

桥接器模式通过将可变维度抽象，并与实现类解耦，使它们可以独立变化，用组合关系代替继承关系。

在该测试中，使用形状基类的对象定义两种形状：Bar和Piece，分别用他们初始化Chocolate基类的子类白巧克力WhiteChocolate和黑巧克力DarkChocolate，并输出他们的全名：X形状Y颜色的巧克力。

理论上如果需要添加新的形状和颜色巧克力种类，也只需分别写继承自形状基类的新形状子类和继承自巧克力基类的巧克力子类即可。实现了形状和巧克力种类的解耦，不需要修改原有类，符合OCP原则。

### 测试用例

1.  分别创建两个形状基类的对象bar和piece
2.  分别用不同的形状基类初始化两种巧克力子类，共4个巧克力子类对象，即用bar初始化的黑/白巧克力以及用piece初始化的黑/白巧克力。
3.  分别输出这四个对象的全名

### 功能测试

![Bridge功能测试](F:\DP\测试文件_雷泓\Bridge（桥接）模式测试\Bridge功能测试.png)

评价：此设计模式存在一个理解上的问题，Bridge实现的是抽象类和实体类的分离解耦，本测试用例中定义了Size形状基类以及Bar和Piece两种继承自Size的形状子类，按理来说，耦合的另一端应该是n个实现巧克力抽象类的不同的种类巧克力的实体类，如WhiteChocolate extends Chocolate，但在这位同学的代码中，只有Chocolate这一个抽象类，然后把巧克力的种类（颜色）作为Chocolate类的属性放在了类里面，并且提供了公共的可以更改巧克力颜色的接口。当我们需要添加巧克力颜色的时候，要进入到initColor()函数中对函数进行更改，这也是不符合OCP法则的。总而言之，这个模式的实现过程中，在对象不可变属性的稳定性上和模式设计（解耦结果）的正确性上都存在着一定的问题。

### 边界测试

无边界测试

## 评分

| 设计模式 | Class/Interface API | framework完成度<br />（正确性25+合理性25） | Sample program/Application<br />（正确性25+合理性25） | 备注 |
| -------- | ------------------- | ------------------------------------------ | ----------------------------------------------------- | ---- |
| Bridge   | Size & Chocolate    | 正确性22+合理性25                          | 正确性23+合理性25                                     |      |

